//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package server

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ChatCompletionMessageToolCallType.
const (
	ChatCompletionMessageToolCallTypeFunction ChatCompletionMessageToolCallType = "function"
)

// Defines values for ChatCompletionMessageToolCallChunkType.
const (
	ChatCompletionMessageToolCallChunkTypeFunction ChatCompletionMessageToolCallChunkType = "function"
)

// Defines values for ChatCompletionNamedToolChoiceType.
const (
	ChatCompletionNamedToolChoiceTypeFunction ChatCompletionNamedToolChoiceType = "function"
)

// Defines values for ChatCompletionRequestAssistantMessageRole.
const (
	ChatCompletionRequestAssistantMessageRoleAssistant ChatCompletionRequestAssistantMessageRole = "assistant"
)

// Defines values for ChatCompletionRequestDeveloperMessageRole.
const (
	ChatCompletionRequestDeveloperMessageRoleDeveloper ChatCompletionRequestDeveloperMessageRole = "developer"
)

// Defines values for ChatCompletionRequestFunctionMessageRole.
const (
	ChatCompletionRequestFunctionMessageRoleFunction ChatCompletionRequestFunctionMessageRole = "function"
)

// Defines values for ChatCompletionRequestMessageContentPartAudioInputAudioFormat.
const (
	ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 ChatCompletionRequestMessageContentPartAudioInputAudioFormat = "mp3"
	ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav ChatCompletionRequestMessageContentPartAudioInputAudioFormat = "wav"
)

// Defines values for ChatCompletionRequestMessageContentPartAudioType.
const (
	InputAudio ChatCompletionRequestMessageContentPartAudioType = "input_audio"
)

// Defines values for ChatCompletionRequestMessageContentPartImageImageUrlDetail.
const (
	ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto ChatCompletionRequestMessageContentPartImageImageUrlDetail = "auto"
	ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh ChatCompletionRequestMessageContentPartImageImageUrlDetail = "high"
	ChatCompletionRequestMessageContentPartImageImageUrlDetailLow  ChatCompletionRequestMessageContentPartImageImageUrlDetail = "low"
)

// Defines values for ChatCompletionRequestMessageContentPartImageType.
const (
	ImageUrl ChatCompletionRequestMessageContentPartImageType = "image_url"
)

// Defines values for ChatCompletionRequestMessageContentPartRefusalType.
const (
	Refusal ChatCompletionRequestMessageContentPartRefusalType = "refusal"
)

// Defines values for ChatCompletionRequestMessageContentPartTextType.
const (
	ChatCompletionRequestMessageContentPartTextTypeText ChatCompletionRequestMessageContentPartTextType = "text"
)

// Defines values for ChatCompletionRequestSystemMessageRole.
const (
	System ChatCompletionRequestSystemMessageRole = "system"
)

// Defines values for ChatCompletionRequestToolMessageRole.
const (
	Tool ChatCompletionRequestToolMessageRole = "tool"
)

// Defines values for ChatCompletionRequestUserMessageRole.
const (
	User ChatCompletionRequestUserMessageRole = "user"
)

// Defines values for ChatCompletionResponseMessageRole.
const (
	ChatCompletionResponseMessageRoleAssistant ChatCompletionResponseMessageRole = "assistant"
)

// Defines values for ChatCompletionStreamResponseDeltaRole.
const (
	ChatCompletionStreamResponseDeltaRoleAssistant ChatCompletionStreamResponseDeltaRole = "assistant"
	ChatCompletionStreamResponseDeltaRoleDeveloper ChatCompletionStreamResponseDeltaRole = "developer"
	ChatCompletionStreamResponseDeltaRoleSystem    ChatCompletionStreamResponseDeltaRole = "system"
	ChatCompletionStreamResponseDeltaRoleTool      ChatCompletionStreamResponseDeltaRole = "tool"
	ChatCompletionStreamResponseDeltaRoleUser      ChatCompletionStreamResponseDeltaRole = "user"
)

// Defines values for ChatCompletionToolType.
const (
	Function ChatCompletionToolType = "function"
)

// Defines values for ChatCompletionToolChoiceOption0.
const (
	ChatCompletionToolChoiceOption0Auto     ChatCompletionToolChoiceOption0 = "auto"
	ChatCompletionToolChoiceOption0None     ChatCompletionToolChoiceOption0 = "none"
	ChatCompletionToolChoiceOption0Required ChatCompletionToolChoiceOption0 = "required"
)

// Defines values for CreateChatCompletionRequestAudioFormat.
const (
	CreateChatCompletionRequestAudioFormatFlac  CreateChatCompletionRequestAudioFormat = "flac"
	CreateChatCompletionRequestAudioFormatMp3   CreateChatCompletionRequestAudioFormat = "mp3"
	CreateChatCompletionRequestAudioFormatOpus  CreateChatCompletionRequestAudioFormat = "opus"
	CreateChatCompletionRequestAudioFormatPcm16 CreateChatCompletionRequestAudioFormat = "pcm16"
	CreateChatCompletionRequestAudioFormatWav   CreateChatCompletionRequestAudioFormat = "wav"
)

// Defines values for CreateChatCompletionRequestAudioVoice.
const (
	Alloy   CreateChatCompletionRequestAudioVoice = "alloy"
	Ash     CreateChatCompletionRequestAudioVoice = "ash"
	Ballad  CreateChatCompletionRequestAudioVoice = "ballad"
	Coral   CreateChatCompletionRequestAudioVoice = "coral"
	Echo    CreateChatCompletionRequestAudioVoice = "echo"
	Sage    CreateChatCompletionRequestAudioVoice = "sage"
	Shimmer CreateChatCompletionRequestAudioVoice = "shimmer"
	Verse   CreateChatCompletionRequestAudioVoice = "verse"
)

// Defines values for CreateChatCompletionRequestFunctionCall0.
const (
	CreateChatCompletionRequestFunctionCall0Auto CreateChatCompletionRequestFunctionCall0 = "auto"
	CreateChatCompletionRequestFunctionCall0None CreateChatCompletionRequestFunctionCall0 = "none"
)

// Defines values for CreateChatCompletionRequestModel1.
const (
	Chatgpt4oLatest               CreateChatCompletionRequestModel1 = "chatgpt-4o-latest"
	Gpt35Turbo                    CreateChatCompletionRequestModel1 = "gpt-3.5-turbo"
	Gpt35Turbo0125                CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0125"
	Gpt35Turbo0301                CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0301"
	Gpt35Turbo0613                CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0613"
	Gpt35Turbo1106                CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-1106"
	Gpt35Turbo16k                 CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-16k"
	Gpt35Turbo16k0613             CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-16k-0613"
	Gpt4                          CreateChatCompletionRequestModel1 = "gpt-4"
	Gpt40125Preview               CreateChatCompletionRequestModel1 = "gpt-4-0125-preview"
	Gpt40314                      CreateChatCompletionRequestModel1 = "gpt-4-0314"
	Gpt40613                      CreateChatCompletionRequestModel1 = "gpt-4-0613"
	Gpt41106Preview               CreateChatCompletionRequestModel1 = "gpt-4-1106-preview"
	Gpt432k                       CreateChatCompletionRequestModel1 = "gpt-4-32k"
	Gpt432k0314                   CreateChatCompletionRequestModel1 = "gpt-4-32k-0314"
	Gpt432k0613                   CreateChatCompletionRequestModel1 = "gpt-4-32k-0613"
	Gpt4Turbo                     CreateChatCompletionRequestModel1 = "gpt-4-turbo"
	Gpt4Turbo20240409             CreateChatCompletionRequestModel1 = "gpt-4-turbo-2024-04-09"
	Gpt4TurboPreview              CreateChatCompletionRequestModel1 = "gpt-4-turbo-preview"
	Gpt4VisionPreview             CreateChatCompletionRequestModel1 = "gpt-4-vision-preview"
	Gpt4o                         CreateChatCompletionRequestModel1 = "gpt-4o"
	Gpt4o20240513                 CreateChatCompletionRequestModel1 = "gpt-4o-2024-05-13"
	Gpt4o20240806                 CreateChatCompletionRequestModel1 = "gpt-4o-2024-08-06"
	Gpt4o20241120                 CreateChatCompletionRequestModel1 = "gpt-4o-2024-11-20"
	Gpt4oAudioPreview             CreateChatCompletionRequestModel1 = "gpt-4o-audio-preview"
	Gpt4oAudioPreview20241001     CreateChatCompletionRequestModel1 = "gpt-4o-audio-preview-2024-10-01"
	Gpt4oAudioPreview20241217     CreateChatCompletionRequestModel1 = "gpt-4o-audio-preview-2024-12-17"
	Gpt4oMini                     CreateChatCompletionRequestModel1 = "gpt-4o-mini"
	Gpt4oMini20240718             CreateChatCompletionRequestModel1 = "gpt-4o-mini-2024-07-18"
	Gpt4oMiniAudioPreview         CreateChatCompletionRequestModel1 = "gpt-4o-mini-audio-preview"
	Gpt4oMiniAudioPreview20241217 CreateChatCompletionRequestModel1 = "gpt-4o-mini-audio-preview-2024-12-17"
	O1                            CreateChatCompletionRequestModel1 = "o1"
	O120241217                    CreateChatCompletionRequestModel1 = "o1-2024-12-17"
	O1Mini                        CreateChatCompletionRequestModel1 = "o1-mini"
	O1Mini20240912                CreateChatCompletionRequestModel1 = "o1-mini-2024-09-12"
	O1Preview                     CreateChatCompletionRequestModel1 = "o1-preview"
	O1Preview20240912             CreateChatCompletionRequestModel1 = "o1-preview-2024-09-12"
	O3Mini                        CreateChatCompletionRequestModel1 = "o3-mini"
	O3Mini20250131                CreateChatCompletionRequestModel1 = "o3-mini-2025-01-31"
)

// Defines values for CreateChatCompletionRequestReasoningEffort.
const (
	High   CreateChatCompletionRequestReasoningEffort = "high"
	Low    CreateChatCompletionRequestReasoningEffort = "low"
	Medium CreateChatCompletionRequestReasoningEffort = "medium"
)

// Defines values for CreateChatCompletionRequestServiceTier.
const (
	CreateChatCompletionRequestServiceTierAuto    CreateChatCompletionRequestServiceTier = "auto"
	CreateChatCompletionRequestServiceTierDefault CreateChatCompletionRequestServiceTier = "default"
)

// Defines values for CreateChatCompletionResponseChoicesFinishReason.
const (
	CreateChatCompletionResponseChoicesFinishReasonContentFilter CreateChatCompletionResponseChoicesFinishReason = "content_filter"
	CreateChatCompletionResponseChoicesFinishReasonFunctionCall  CreateChatCompletionResponseChoicesFinishReason = "function_call"
	CreateChatCompletionResponseChoicesFinishReasonLength        CreateChatCompletionResponseChoicesFinishReason = "length"
	CreateChatCompletionResponseChoicesFinishReasonStop          CreateChatCompletionResponseChoicesFinishReason = "stop"
	CreateChatCompletionResponseChoicesFinishReasonToolCalls     CreateChatCompletionResponseChoicesFinishReason = "tool_calls"
)

// Defines values for CreateChatCompletionResponseObject.
const (
	ChatCompletion CreateChatCompletionResponseObject = "chat.completion"
)

// Defines values for CreateChatCompletionResponseServiceTier.
const (
	CreateChatCompletionResponseServiceTierDefault CreateChatCompletionResponseServiceTier = "default"
	CreateChatCompletionResponseServiceTierScale   CreateChatCompletionResponseServiceTier = "scale"
)

// Defines values for CreateChatCompletionStreamResponseChoicesFinishReason.
const (
	CreateChatCompletionStreamResponseChoicesFinishReasonContentFilter CreateChatCompletionStreamResponseChoicesFinishReason = "content_filter"
	CreateChatCompletionStreamResponseChoicesFinishReasonFunctionCall  CreateChatCompletionStreamResponseChoicesFinishReason = "function_call"
	CreateChatCompletionStreamResponseChoicesFinishReasonLength        CreateChatCompletionStreamResponseChoicesFinishReason = "length"
	CreateChatCompletionStreamResponseChoicesFinishReasonStop          CreateChatCompletionStreamResponseChoicesFinishReason = "stop"
	CreateChatCompletionStreamResponseChoicesFinishReasonToolCalls     CreateChatCompletionStreamResponseChoicesFinishReason = "tool_calls"
)

// Defines values for CreateChatCompletionStreamResponseObject.
const (
	ChatCompletionChunk CreateChatCompletionStreamResponseObject = "chat.completion.chunk"
)

// Defines values for CreateChatCompletionStreamResponseServiceTier.
const (
	CreateChatCompletionStreamResponseServiceTierDefault CreateChatCompletionStreamResponseServiceTier = "default"
	CreateChatCompletionStreamResponseServiceTierScale   CreateChatCompletionStreamResponseServiceTier = "scale"
)

// Defines values for CreateCompletionRequestModel1.
const (
	Babbage002         CreateCompletionRequestModel1 = "babbage-002"
	Davinci002         CreateCompletionRequestModel1 = "davinci-002"
	Gpt35TurboInstruct CreateCompletionRequestModel1 = "gpt-3.5-turbo-instruct"
)

// Defines values for CreateCompletionResponseChoicesFinishReason.
const (
	ContentFilter CreateCompletionResponseChoicesFinishReason = "content_filter"
	Length        CreateCompletionResponseChoicesFinishReason = "length"
	Stop          CreateCompletionResponseChoicesFinishReason = "stop"
)

// Defines values for CreateCompletionResponseObject.
const (
	TextCompletion CreateCompletionResponseObject = "text_completion"
)

// Defines values for CreateEmbeddingRequestEncodingFormat.
const (
	Base64 CreateEmbeddingRequestEncodingFormat = "base64"
	Float  CreateEmbeddingRequestEncodingFormat = "float"
)

// Defines values for CreateEmbeddingRequestModel1.
const (
	TextEmbedding3Large CreateEmbeddingRequestModel1 = "text-embedding-3-large"
	TextEmbedding3Small CreateEmbeddingRequestModel1 = "text-embedding-3-small"
	TextEmbeddingAda002 CreateEmbeddingRequestModel1 = "text-embedding-ada-002"
)

// Defines values for CreateEmbeddingResponseObject.
const (
	List CreateEmbeddingResponseObject = "list"
)

// Defines values for EmbeddingObject.
const (
	EmbeddingObjectEmbedding EmbeddingObject = "embedding"
)

// Defines values for PredictionContentType.
const (
	Content PredictionContentType = "content"
)

// Defines values for ResponseFormatJsonObjectType.
const (
	JsonObject ResponseFormatJsonObjectType = "json_object"
)

// Defines values for ResponseFormatJsonSchemaType.
const (
	JsonSchema ResponseFormatJsonSchemaType = "json_schema"
)

// Defines values for ResponseFormatTextType.
const (
	ResponseFormatTextTypeText ResponseFormatTextType = "text"
)

// ChatCompletionFunctionCallOption Specifying a particular function via `{"name": "my_function"}` forces the model to call that function.
type ChatCompletionFunctionCallOption struct {
	// Name The name of the function to call.
	Name string `json:"name"`
}

// ChatCompletionFunctions defines model for ChatCompletionFunctions.
type ChatCompletionFunctions struct {
	// Description A description of what the function does, used by the model to choose when and how to call the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// Parameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
	//
	// Omitting `parameters` defines a function with an empty parameter list.
	Parameters *FunctionParameters `json:"parameters,omitempty"`
}

// ChatCompletionMessageToolCall defines model for ChatCompletionMessageToolCall.
type ChatCompletionMessageToolCall struct {
	// Function The function that the model called.
	Function struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function"`

	// Id The ID of the tool call.
	Id string `json:"id"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionMessageToolCallType `json:"type"`
}

// ChatCompletionMessageToolCallType The type of the tool. Currently, only `function` is supported.
type ChatCompletionMessageToolCallType string

// ChatCompletionMessageToolCallChunk defines model for ChatCompletionMessageToolCallChunk.
type ChatCompletionMessageToolCallChunk struct {
	Function *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments *string `json:"arguments,omitempty"`

		// Name The name of the function to call.
		Name *string `json:"name,omitempty"`
	} `json:"function,omitempty"`

	// Id The ID of the tool call.
	Id    *string `json:"id,omitempty"`
	Index int     `json:"index"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type *ChatCompletionMessageToolCallChunkType `json:"type,omitempty"`
}

// ChatCompletionMessageToolCallChunkType The type of the tool. Currently, only `function` is supported.
type ChatCompletionMessageToolCallChunkType string

// ChatCompletionMessageToolCalls The tool calls generated by the model, such as function calls.
type ChatCompletionMessageToolCalls = []ChatCompletionMessageToolCall

// ChatCompletionModalities Output types that you would like the model to generate for this request.
// Most models are capable of generating text, which is the default:
//
// `["text"]`
//
// The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To
// request that this model generate both text and audio responses, you can
// use:
//
// `["text", "audio"]`
type ChatCompletionModalities = []string

// ChatCompletionNamedToolChoice Specifies a tool the model should use. Use to force the model to call a specific function.
type ChatCompletionNamedToolChoice struct {
	Function struct {
		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionNamedToolChoiceType `json:"type"`
}

// ChatCompletionNamedToolChoiceType The type of the tool. Currently, only `function` is supported.
type ChatCompletionNamedToolChoiceType string

// ChatCompletionRequestAssistantMessage Messages sent by the model in response to user messages.
type ChatCompletionRequestAssistantMessage struct {
	// Audio Data about a previous audio response from the model.
	// [Learn more](/docs/guides/audio).
	Audio *struct {
		// Id Unique identifier for a previous audio response from the model.
		Id string `json:"id"`
	} `json:"audio"`

	// Content The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
	Content *ChatCompletionRequestAssistantMessage_Content `json:"content"`

	// FunctionCall Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
	// Deprecated:
	FunctionCall *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function_call"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Refusal The refusal message by the assistant.
	Refusal *string `json:"refusal"`

	// Role The role of the messages author, in this case `assistant`.
	Role ChatCompletionRequestAssistantMessageRole `json:"role"`

	// ToolCalls The tool calls generated by the model, such as function calls.
	ToolCalls *ChatCompletionMessageToolCalls `json:"tool_calls,omitempty"`
}

// ChatCompletionRequestAssistantMessageContent0 The contents of the assistant message.
type ChatCompletionRequestAssistantMessageContent0 = string

// ChatCompletionRequestAssistantMessageContent1 An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`.
type ChatCompletionRequestAssistantMessageContent1 = []ChatCompletionRequestAssistantMessageContentPart

// ChatCompletionRequestAssistantMessage_Content The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
type ChatCompletionRequestAssistantMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestAssistantMessageRole The role of the messages author, in this case `assistant`.
type ChatCompletionRequestAssistantMessageRole string

// ChatCompletionRequestAssistantMessageContentPart defines model for ChatCompletionRequestAssistantMessageContentPart.
type ChatCompletionRequestAssistantMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestDeveloperMessage Developer-provided instructions that the model should follow, regardless of
// messages sent by the user. With o1 models and newer, `developer` messages
// replace the previous `system` messages.
type ChatCompletionRequestDeveloperMessage struct {
	// Content The contents of the developer message.
	Content ChatCompletionRequestDeveloperMessage_Content `json:"content"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Role The role of the messages author, in this case `developer`.
	Role ChatCompletionRequestDeveloperMessageRole `json:"role"`
}

// ChatCompletionRequestDeveloperMessageContent0 The contents of the developer message.
type ChatCompletionRequestDeveloperMessageContent0 = string

// ChatCompletionRequestDeveloperMessageContent1 An array of content parts with a defined type. For developer messages, only type `text` is supported.
type ChatCompletionRequestDeveloperMessageContent1 = []ChatCompletionRequestMessageContentPartText

// ChatCompletionRequestDeveloperMessage_Content The contents of the developer message.
type ChatCompletionRequestDeveloperMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestDeveloperMessageRole The role of the messages author, in this case `developer`.
type ChatCompletionRequestDeveloperMessageRole string

// ChatCompletionRequestFunctionMessage defines model for ChatCompletionRequestFunctionMessage.
type ChatCompletionRequestFunctionMessage struct {
	// Content The contents of the function message.
	Content *string `json:"content"`

	// Name The name of the function to call.
	Name string `json:"name"`

	// Role The role of the messages author, in this case `function`.
	Role ChatCompletionRequestFunctionMessageRole `json:"role"`
}

// ChatCompletionRequestFunctionMessageRole The role of the messages author, in this case `function`.
type ChatCompletionRequestFunctionMessageRole string

// ChatCompletionRequestMessage defines model for ChatCompletionRequestMessage.
type ChatCompletionRequestMessage struct {
	union json.RawMessage
}

// ChatCompletionRequestMessageContentPartAudio Learn about [audio inputs](/docs/guides/audio).
type ChatCompletionRequestMessageContentPartAudio struct {
	InputAudio struct {
		// Data Base64 encoded audio data.
		Data string `json:"data"`

		// Format The format of the encoded audio data. Currently supports "wav" and "mp3".
		Format ChatCompletionRequestMessageContentPartAudioInputAudioFormat `json:"format"`
	} `json:"input_audio"`

	// Type The type of the content part. Always `input_audio`.
	Type ChatCompletionRequestMessageContentPartAudioType `json:"type"`
}

// ChatCompletionRequestMessageContentPartAudioInputAudioFormat The format of the encoded audio data. Currently supports "wav" and "mp3".
type ChatCompletionRequestMessageContentPartAudioInputAudioFormat string

// ChatCompletionRequestMessageContentPartAudioType The type of the content part. Always `input_audio`.
type ChatCompletionRequestMessageContentPartAudioType string

// ChatCompletionRequestMessageContentPartImage Learn about [image inputs](/docs/guides/vision).
type ChatCompletionRequestMessageContentPartImage struct {
	ImageUrl struct {
		// Detail Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
		Detail *ChatCompletionRequestMessageContentPartImageImageUrlDetail `json:"detail,omitempty"`

		// Url Either a URL of the image or the base64 encoded image data.
		Url string `json:"url"`
	} `json:"image_url"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartImageType `json:"type"`
}

// ChatCompletionRequestMessageContentPartImageImageUrlDetail Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
type ChatCompletionRequestMessageContentPartImageImageUrlDetail string

// ChatCompletionRequestMessageContentPartImageType The type of the content part.
type ChatCompletionRequestMessageContentPartImageType string

// ChatCompletionRequestMessageContentPartRefusal defines model for ChatCompletionRequestMessageContentPartRefusal.
type ChatCompletionRequestMessageContentPartRefusal struct {
	// Refusal The refusal message generated by the model.
	Refusal string `json:"refusal"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartRefusalType `json:"type"`
}

// ChatCompletionRequestMessageContentPartRefusalType The type of the content part.
type ChatCompletionRequestMessageContentPartRefusalType string

// ChatCompletionRequestMessageContentPartText Learn about [text inputs](/docs/guides/text-generation).
type ChatCompletionRequestMessageContentPartText struct {
	// Text The text content.
	Text string `json:"text"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartTextType `json:"type"`
}

// ChatCompletionRequestMessageContentPartTextType The type of the content part.
type ChatCompletionRequestMessageContentPartTextType string

// ChatCompletionRequestSystemMessage Developer-provided instructions that the model should follow, regardless of
// messages sent by the user. With o1 models and newer, use `developer` messages
// for this purpose instead.
type ChatCompletionRequestSystemMessage struct {
	// Content The contents of the system message.
	Content ChatCompletionRequestSystemMessage_Content `json:"content"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Role The role of the messages author, in this case `system`.
	Role ChatCompletionRequestSystemMessageRole `json:"role"`
}

// ChatCompletionRequestSystemMessageContent0 The contents of the system message.
type ChatCompletionRequestSystemMessageContent0 = string

// ChatCompletionRequestSystemMessageContent1 An array of content parts with a defined type. For system messages, only type `text` is supported.
type ChatCompletionRequestSystemMessageContent1 = []ChatCompletionRequestSystemMessageContentPart

// ChatCompletionRequestSystemMessage_Content The contents of the system message.
type ChatCompletionRequestSystemMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestSystemMessageRole The role of the messages author, in this case `system`.
type ChatCompletionRequestSystemMessageRole string

// ChatCompletionRequestSystemMessageContentPart defines model for ChatCompletionRequestSystemMessageContentPart.
type ChatCompletionRequestSystemMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestToolMessage defines model for ChatCompletionRequestToolMessage.
type ChatCompletionRequestToolMessage struct {
	// Content The contents of the tool message.
	Content ChatCompletionRequestToolMessage_Content `json:"content"`

	// Role The role of the messages author, in this case `tool`.
	Role ChatCompletionRequestToolMessageRole `json:"role"`

	// ToolCallId Tool call that this message is responding to.
	ToolCallId string `json:"tool_call_id"`
}

// ChatCompletionRequestToolMessageContent0 The contents of the tool message.
type ChatCompletionRequestToolMessageContent0 = string

// ChatCompletionRequestToolMessageContent1 An array of content parts with a defined type. For tool messages, only type `text` is supported.
type ChatCompletionRequestToolMessageContent1 = []ChatCompletionRequestToolMessageContentPart

// ChatCompletionRequestToolMessage_Content The contents of the tool message.
type ChatCompletionRequestToolMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestToolMessageRole The role of the messages author, in this case `tool`.
type ChatCompletionRequestToolMessageRole string

// ChatCompletionRequestToolMessageContentPart defines model for ChatCompletionRequestToolMessageContentPart.
type ChatCompletionRequestToolMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestUserMessage Messages sent by an end user, containing prompts or additional context
// information.
type ChatCompletionRequestUserMessage struct {
	// Content The contents of the user message.
	Content ChatCompletionRequestUserMessage_Content `json:"content"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Role The role of the messages author, in this case `user`.
	Role ChatCompletionRequestUserMessageRole `json:"role"`
}

// ChatCompletionRequestUserMessageContent0 The text contents of the message.
type ChatCompletionRequestUserMessageContent0 = string

// ChatCompletionRequestUserMessageContent1 An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text, image, or audio inputs.
type ChatCompletionRequestUserMessageContent1 = []ChatCompletionRequestUserMessageContentPart

// ChatCompletionRequestUserMessage_Content The contents of the user message.
type ChatCompletionRequestUserMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestUserMessageRole The role of the messages author, in this case `user`.
type ChatCompletionRequestUserMessageRole string

// ChatCompletionRequestUserMessageContentPart defines model for ChatCompletionRequestUserMessageContentPart.
type ChatCompletionRequestUserMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionResponseMessage A chat completion message generated by the model.
type ChatCompletionResponseMessage struct {
	// Audio If the audio output modality is requested, this object contains data
	// about the audio response from the model. [Learn more](/docs/guides/audio).
	Audio *struct {
		// Data Base64 encoded audio bytes generated by the model, in the format
		// specified in the request.
		Data string `json:"data"`

		// ExpiresAt The Unix timestamp (in seconds) for when this audio response will
		// no longer be accessible on the server for use in multi-turn
		// conversations.
		ExpiresAt int `json:"expires_at"`

		// Id Unique identifier for this audio response.
		Id string `json:"id"`

		// Transcript Transcript of the audio generated by the model.
		Transcript string `json:"transcript"`
	} `json:"audio"`

	// Content The contents of the message.
	Content *string `json:"content"`

	// FunctionCall Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
	// Deprecated:
	FunctionCall *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function_call,omitempty"`

	// Refusal The refusal message generated by the model.
	Refusal *string `json:"refusal"`

	// Role The role of the author of this message.
	Role ChatCompletionResponseMessageRole `json:"role"`

	// ToolCalls The tool calls generated by the model, such as function calls.
	ToolCalls *ChatCompletionMessageToolCalls `json:"tool_calls,omitempty"`
}

// ChatCompletionResponseMessageRole The role of the author of this message.
type ChatCompletionResponseMessageRole string

// ChatCompletionStreamOptions Options for streaming response. Only set this when you set `stream: true`.
type ChatCompletionStreamOptions struct {
	// IncludeUsage If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
	IncludeUsage *bool `json:"include_usage,omitempty"`
}

// ChatCompletionStreamResponseDelta A chat completion delta generated by streamed model responses.
type ChatCompletionStreamResponseDelta struct {
	// Content The contents of the chunk message.
	Content *string `json:"content"`

	// FunctionCall Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
	// Deprecated:
	FunctionCall *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments *string `json:"arguments,omitempty"`

		// Name The name of the function to call.
		Name *string `json:"name,omitempty"`
	} `json:"function_call,omitempty"`

	// Refusal The refusal message generated by the model.
	Refusal *string `json:"refusal"`

	// Role The role of the author of this message.
	Role      *ChatCompletionStreamResponseDeltaRole `json:"role,omitempty"`
	ToolCalls *[]ChatCompletionMessageToolCallChunk  `json:"tool_calls,omitempty"`
}

// ChatCompletionStreamResponseDeltaRole The role of the author of this message.
type ChatCompletionStreamResponseDeltaRole string

// ChatCompletionTokenLogprob defines model for ChatCompletionTokenLogprob.
type ChatCompletionTokenLogprob struct {
	// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
	Bytes *[]int `json:"bytes"`

	// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
	Logprob float32 `json:"logprob"`

	// Token The token.
	Token string `json:"token"`

	// TopLogprobs List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
	TopLogprobs []struct {
		// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
		Bytes *[]int `json:"bytes"`

		// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
		Logprob float32 `json:"logprob"`

		// Token The token.
		Token string `json:"token"`
	} `json:"top_logprobs"`
}

// ChatCompletionTool defines model for ChatCompletionTool.
type ChatCompletionTool struct {
	Function FunctionObject `json:"function"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionToolType `json:"type"`
}

// ChatCompletionToolType The type of the tool. Currently, only `function` is supported.
type ChatCompletionToolType string

// ChatCompletionToolChoiceOption Controls which (if any) tool is called by the model.
// `none` means the model will not call any tool and instead generates a message.
// `auto` means the model can pick between generating a message or calling one or more tools.
// `required` means the model must call one or more tools.
// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
//
// `none` is the default when no tools are present. `auto` is the default if tools are present.
type ChatCompletionToolChoiceOption struct {
	union json.RawMessage
}

// ChatCompletionToolChoiceOption0 `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools.
type ChatCompletionToolChoiceOption0 string

// CompletionUsage Usage statistics for the completion request.
type CompletionUsage struct {
	// CompletionTokens Number of tokens in the generated completion.
	CompletionTokens int `json:"completion_tokens"`

	// CompletionTokensDetails Breakdown of tokens used in a completion.
	CompletionTokensDetails *struct {
		// AcceptedPredictionTokens When using Predicted Outputs, the number of tokens in the
		// prediction that appeared in the completion.
		AcceptedPredictionTokens *int `json:"accepted_prediction_tokens,omitempty"`

		// AudioTokens Audio input tokens generated by the model.
		AudioTokens *int `json:"audio_tokens,omitempty"`

		// ReasoningTokens Tokens generated by the model for reasoning.
		ReasoningTokens *int `json:"reasoning_tokens,omitempty"`

		// RejectedPredictionTokens When using Predicted Outputs, the number of tokens in the
		// prediction that did not appear in the completion. However, like
		// reasoning tokens, these tokens are still counted in the total
		// completion tokens for purposes of billing, output, and context window
		// limits.
		RejectedPredictionTokens *int `json:"rejected_prediction_tokens,omitempty"`
	} `json:"completion_tokens_details,omitempty"`

	// PromptTokens Number of tokens in the prompt.
	PromptTokens int `json:"prompt_tokens"`

	// PromptTokensDetails Breakdown of tokens used in the prompt.
	PromptTokensDetails *struct {
		// AudioTokens Audio input tokens present in the prompt.
		AudioTokens *int `json:"audio_tokens,omitempty"`

		// CachedTokens Cached tokens present in the prompt.
		CachedTokens *int `json:"cached_tokens,omitempty"`
	} `json:"prompt_tokens_details,omitempty"`

	// TotalTokens Total number of tokens used in the request (prompt + completion).
	TotalTokens int `json:"total_tokens"`
}

// CreateChatCompletionRequest defines model for CreateChatCompletionRequest.
type CreateChatCompletionRequest struct {
	// Audio Parameters for audio output. Required when audio output is requested with
	// `modalities: ["audio"]`. [Learn more](/docs/guides/audio).
	Audio *struct {
		// Format Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,
		// `opus`, or `pcm16`.
		Format CreateChatCompletionRequestAudioFormat `json:"format"`

		// Voice The voice the model uses to respond. Supported voices are `ash`, `ballad`, `coral`, `sage`, and `verse` (also supported but not recommended are `alloy`, `echo`, and `shimmer`; these voices are less expressive).
		Voice CreateChatCompletionRequestAudioVoice `json:"voice"`
	} `json:"audio"`

	// FrequencyPenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on
	// their existing frequency in the text so far, decreasing the model's
	// likelihood to repeat the same line verbatim.
	FrequencyPenalty *float32 `json:"frequency_penalty"`

	// FunctionCall Deprecated in favor of `tool_choice`.
	//
	// Controls which (if any) function is called by the model.
	//
	// `none` means the model will not call a function and instead generates a
	// message.
	//
	// `auto` means the model can pick between generating a message or calling a
	// function.
	//
	// Specifying a particular function via `{"name": "my_function"}` forces the
	// model to call that function.
	//
	// `none` is the default when no functions are present. `auto` is the default
	// if functions are present.
	// Deprecated:
	FunctionCall *CreateChatCompletionRequest_FunctionCall `json:"function_call,omitempty"`

	// Functions Deprecated in favor of `tools`.
	//
	// A list of functions the model may generate JSON inputs for.
	// Deprecated:
	Functions *[]ChatCompletionFunctions `json:"functions,omitempty"`

	// LogitBias Modify the likelihood of specified tokens appearing in the completion.
	//
	// Accepts a JSON object that maps tokens (specified by their token ID in the
	// tokenizer) to an associated bias value from -100 to 100. Mathematically,
	// the bias is added to the logits generated by the model prior to sampling.
	// The exact effect will vary per model, but values between -1 and 1 should
	// decrease or increase likelihood of selection; values like -100 or 100
	// should result in a ban or exclusive selection of the relevant token.
	LogitBias *map[string]int `json:"logit_bias"`

	// Logprobs Whether to return log probabilities of the output tokens or not. If true,
	// returns the log probabilities of each output token returned in the
	// `content` of `message`.
	Logprobs *bool `json:"logprobs"`

	// MaxCompletionTokens An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).
	MaxCompletionTokens *int `json:"max_completion_tokens"`

	// MaxTokens The maximum number of [tokens](/tokenizer) that can be generated in the
	// chat completion. This value can be used to control
	// [costs](https://openai.com/api/pricing/) for text generated via API.
	//
	// This value is now deprecated in favor of `max_completion_tokens`, and is
	// not compatible with [o1 series models](/docs/guides/reasoning).
	// Deprecated:
	MaxTokens *int `json:"max_tokens"`

	// Messages A list of messages comprising the conversation so far. Depending on the
	// [model](/docs/models) you use, different message types (modalities) are
	// supported, like [text](/docs/guides/text-generation),
	// [images](/docs/guides/vision), and [audio](/docs/guides/audio).
	Messages []ChatCompletionRequestMessage `json:"messages"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be
	// useful for storing additional information about the object in a structured
	// format, and querying for objects via API or the dashboard.
	//
	// Keys are strings with a maximum length of 64 characters. Values are strings
	// with a maximum length of 512 characters.
	Metadata *Metadata `json:"metadata"`

	// Modalities Output types that you would like the model to generate for this request.
	// Most models are capable of generating text, which is the default:
	//
	// `["text"]`
	//
	// The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To
	// request that this model generate both text and audio responses, you can
	// use:
	//
	// `["text", "audio"]`
	Modalities *ChatCompletionModalities `json:"modalities"`

	// Model ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
	Model CreateChatCompletionRequest_Model `json:"model"`

	// N How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
	N *int `json:"n"`

	// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
	ParallelToolCalls *ParallelToolCalls `json:"parallel_tool_calls,omitempty"`

	// Prediction Configuration for a [Predicted Output](/docs/guides/predicted-outputs),
	// which can greatly improve response times when large parts of the model
	// response are known ahead of time. This is most common when you are
	// regenerating a file with only minor changes to most of the content.
	Prediction *CreateChatCompletionRequest_Prediction `json:"prediction"`

	// PresencePenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on
	// whether they appear in the text so far, increasing the model's likelihood
	// to talk about new topics.
	PresencePenalty *float32 `json:"presence_penalty"`

	// ReasoningEffort **o1 models only**
	//
	// Constrains effort on reasoning for
	// [reasoning models](https://platform.openai.com/docs/guides/reasoning).
	// Currently supported values are `low`, `medium`, and `high`. Reducing
	// reasoning effort can result in faster responses and fewer tokens used
	// on reasoning in a response.
	ReasoningEffort *CreateChatCompletionRequestReasoningEffort `json:"reasoning_effort,omitempty"`

	// ResponseFormat An object specifying the format that the model must output.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables
	// Structured Outputs which ensures the model will match your supplied JSON
	// schema. Learn more in the [Structured Outputs
	// guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures
	// the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model
	// to produce JSON yourself via a system or user message. Without this, the
	// model may generate an unending stream of whitespace until the generation
	// reaches the token limit, resulting in a long-running and seemingly "stuck"
	// request. Also note that the message content may be partially cut off if
	// `finish_reason="length"`, which indicates the generation exceeded
	// `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *CreateChatCompletionRequest_ResponseFormat `json:"response_format,omitempty"`

	// Seed This feature is in Beta.
	// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
	// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
	Seed *int64 `json:"seed"`

	// ServiceTier Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:
	//   - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.
	//   - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
	//   - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
	//   - When not set, the default behavior is 'auto'.
	ServiceTier *CreateChatCompletionRequestServiceTier `json:"service_tier"`

	// Stop Up to 4 sequences where the API will stop generating further tokens.
	Stop *CreateChatCompletionRequest_Stop `json:"stop,omitempty"`

	// Store Whether or not to store the output of this chat completion request for
	// use in our [model distillation](/docs/guides/distillation) or
	// [evals](/docs/guides/evals) products.
	Store *bool `json:"store"`

	// Stream If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
	Stream *bool `json:"stream"`

	// StreamOptions Options for streaming response. Only set this when you set `stream: true`.
	StreamOptions *ChatCompletionStreamOptions `json:"stream_options"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	// We generally recommend altering this or `top_p` but not both.
	Temperature *float32 `json:"temperature"`

	// ToolChoice Controls which (if any) tool is called by the model.
	// `none` means the model will not call any tool and instead generates a message.
	// `auto` means the model can pick between generating a message or calling one or more tools.
	// `required` means the model must call one or more tools.
	// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
	//
	// `none` is the default when no tools are present. `auto` is the default if tools are present.
	ToolChoice *ChatCompletionToolChoiceOption `json:"tool_choice,omitempty"`

	// Tools A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
	Tools *[]ChatCompletionTool `json:"tools,omitempty"`

	// TopLogprobs An integer between 0 and 20 specifying the number of most likely tokens to
	// return at each token position, each with an associated log probability.
	// `logprobs` must be set to `true` if this parameter is used.
	TopLogprobs *int `json:"top_logprobs"`

	// TopP An alternative to sampling with temperature, called nucleus sampling,
	// where the model considers the results of the tokens with top_p probability
	// mass. So 0.1 means only the tokens comprising the top 10% probability mass
	// are considered.
	//
	// We generally recommend altering this or `temperature` but not both.
	TopP *float32 `json:"top_p"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateChatCompletionRequestAudioFormat Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,
// `opus`, or `pcm16`.
type CreateChatCompletionRequestAudioFormat string

// CreateChatCompletionRequestAudioVoice The voice the model uses to respond. Supported voices are `ash`, `ballad`, `coral`, `sage`, and `verse` (also supported but not recommended are `alloy`, `echo`, and `shimmer`; these voices are less expressive).
type CreateChatCompletionRequestAudioVoice string

// CreateChatCompletionRequestFunctionCall0 `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function.
type CreateChatCompletionRequestFunctionCall0 string

// CreateChatCompletionRequest_FunctionCall Deprecated in favor of `tool_choice`.
//
// Controls which (if any) function is called by the model.
//
// `none` means the model will not call a function and instead generates a
// message.
//
// `auto` means the model can pick between generating a message or calling a
// function.
//
// Specifying a particular function via `{"name": "my_function"}` forces the
// model to call that function.
//
// `none` is the default when no functions are present. `auto` is the default
// if functions are present.
type CreateChatCompletionRequest_FunctionCall struct {
	union json.RawMessage
}

// CreateChatCompletionRequestModel0 defines model for .
type CreateChatCompletionRequestModel0 = string

// CreateChatCompletionRequestModel1 defines model for CreateChatCompletionRequest.Model.1.
type CreateChatCompletionRequestModel1 string

// CreateChatCompletionRequest_Model ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
type CreateChatCompletionRequest_Model struct {
	union json.RawMessage
}

// CreateChatCompletionRequest_Prediction Configuration for a [Predicted Output](/docs/guides/predicted-outputs),
// which can greatly improve response times when large parts of the model
// response are known ahead of time. This is most common when you are
// regenerating a file with only minor changes to most of the content.
type CreateChatCompletionRequest_Prediction struct {
	union json.RawMessage
}

// CreateChatCompletionRequestReasoningEffort **o1 models only**
//
// Constrains effort on reasoning for
// [reasoning models](https://platform.openai.com/docs/guides/reasoning).
// Currently supported values are `low`, `medium`, and `high`. Reducing
// reasoning effort can result in faster responses and fewer tokens used
// on reasoning in a response.
type CreateChatCompletionRequestReasoningEffort string

// CreateChatCompletionRequest_ResponseFormat An object specifying the format that the model must output.
//
// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables
// Structured Outputs which ensures the model will match your supplied JSON
// schema. Learn more in the [Structured Outputs
// guide](/docs/guides/structured-outputs).
//
// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures
// the message the model generates is valid JSON.
//
// **Important:** when using JSON mode, you **must** also instruct the model
// to produce JSON yourself via a system or user message. Without this, the
// model may generate an unending stream of whitespace until the generation
// reaches the token limit, resulting in a long-running and seemingly "stuck"
// request. Also note that the message content may be partially cut off if
// `finish_reason="length"`, which indicates the generation exceeded
// `max_tokens` or the conversation exceeded the max context length.
type CreateChatCompletionRequest_ResponseFormat struct {
	union json.RawMessage
}

// CreateChatCompletionRequestServiceTier Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:
//   - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.
//   - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
//   - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.
//   - When not set, the default behavior is 'auto'.
type CreateChatCompletionRequestServiceTier string

// CreateChatCompletionRequestStop0 defines model for .
type CreateChatCompletionRequestStop0 = string

// CreateChatCompletionRequestStop1 defines model for .
type CreateChatCompletionRequestStop1 = []string

// CreateChatCompletionRequest_Stop Up to 4 sequences where the API will stop generating further tokens.
type CreateChatCompletionRequest_Stop struct {
	union json.RawMessage
}

// CreateChatCompletionResponse Represents a chat completion response returned by model, based on the provided input.
type CreateChatCompletionResponse struct {
	// Choices A list of chat completion choices. Can be more than one if `n` is greater than 1.
	Choices []struct {
		// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
		// `length` if the maximum number of tokens specified in the request was reached,
		// `content_filter` if content was omitted due to a flag from our content filters,
		// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
		FinishReason CreateChatCompletionResponseChoicesFinishReason `json:"finish_reason"`

		// Index The index of the choice in the list of choices.
		Index int `json:"index"`

		// Logprobs Log probability information for the choice.
		Logprobs *struct {
			// Content A list of message content tokens with log probability information.
			Content *[]ChatCompletionTokenLogprob `json:"content"`

			// Refusal A list of message refusal tokens with log probability information.
			Refusal *[]ChatCompletionTokenLogprob `json:"refusal"`
		} `json:"logprobs"`

		// Message A chat completion message generated by the model.
		Message ChatCompletionResponseMessage `json:"message"`
	} `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the chat completion was created.
	Created int `json:"created"`

	// Id A unique identifier for the chat completion.
	Id string `json:"id"`

	// Model The model used for the chat completion.
	Model string `json:"model"`

	// Object The object type, which is always `chat.completion`.
	Object CreateChatCompletionResponseObject `json:"object"`

	// ServiceTier The service tier used for processing the request.
	ServiceTier *CreateChatCompletionResponseServiceTier `json:"service_tier"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	//
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// CreateChatCompletionResponseChoicesFinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// `content_filter` if content was omitted due to a flag from our content filters,
// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
type CreateChatCompletionResponseChoicesFinishReason string

// CreateChatCompletionResponseObject The object type, which is always `chat.completion`.
type CreateChatCompletionResponseObject string

// CreateChatCompletionResponseServiceTier The service tier used for processing the request.
type CreateChatCompletionResponseServiceTier string

// CreateChatCompletionStreamResponse Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
type CreateChatCompletionStreamResponse struct {
	// Choices A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
	// last chunk if you set `stream_options: {"include_usage": true}`.
	Choices []struct {
		// Delta A chat completion delta generated by streamed model responses.
		Delta ChatCompletionStreamResponseDelta `json:"delta"`

		// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
		// `length` if the maximum number of tokens specified in the request was reached,
		// `content_filter` if content was omitted due to a flag from our content filters,
		// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
		FinishReason *CreateChatCompletionStreamResponseChoicesFinishReason `json:"finish_reason"`

		// Index The index of the choice in the list of choices.
		Index int `json:"index"`

		// Logprobs Log probability information for the choice.
		Logprobs *struct {
			// Content A list of message content tokens with log probability information.
			Content *[]ChatCompletionTokenLogprob `json:"content"`

			// Refusal A list of message refusal tokens with log probability information.
			Refusal *[]ChatCompletionTokenLogprob `json:"refusal"`
		} `json:"logprobs"`
	} `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
	Created int `json:"created"`

	// Id A unique identifier for the chat completion. Each chunk has the same ID.
	Id string `json:"id"`

	// Model The model to generate the completion.
	Model string `json:"model"`

	// Object The object type, which is always `chat.completion.chunk`.
	Object CreateChatCompletionStreamResponseObject `json:"object"`

	// ServiceTier The service tier used for processing the request.
	ServiceTier *CreateChatCompletionStreamResponseServiceTier `json:"service_tier"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage An optional field that will only be present when you set `stream_options: {"include_usage": true}` in your request.
	// When present, it contains a null value except for the last chunk which contains the token usage statistics for the entire request.
	Usage *struct {
		// CompletionTokens Number of tokens in the generated completion.
		CompletionTokens int `json:"completion_tokens"`

		// PromptTokens Number of tokens in the prompt.
		PromptTokens int `json:"prompt_tokens"`

		// TotalTokens Total number of tokens used in the request (prompt + completion).
		TotalTokens int `json:"total_tokens"`
	} `json:"usage"`
}

// CreateChatCompletionStreamResponseChoicesFinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// `content_filter` if content was omitted due to a flag from our content filters,
// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
type CreateChatCompletionStreamResponseChoicesFinishReason string

// CreateChatCompletionStreamResponseObject The object type, which is always `chat.completion.chunk`.
type CreateChatCompletionStreamResponseObject string

// CreateChatCompletionStreamResponseServiceTier The service tier used for processing the request.
type CreateChatCompletionStreamResponseServiceTier string

// CreateCompletionRequest defines model for CreateCompletionRequest.
type CreateCompletionRequest struct {
	// BestOf Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
	//
	// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.
	//
	// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
	BestOf *int `json:"best_of"`

	// Echo Echo back the prompt in addition to the completion
	Echo *bool `json:"echo"`

	// FrequencyPenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	FrequencyPenalty *float32 `json:"frequency_penalty"`

	// LogitBias Modify the likelihood of specified tokens appearing in the completion.
	//
	// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
	//
	// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
	LogitBias *map[string]int `json:"logit_bias"`

	// Logprobs Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
	//
	// The maximum value for `logprobs` is 5.
	Logprobs *int `json:"logprobs"`

	// MaxTokens The maximum number of [tokens](/tokenizer) that can be generated in the completion.
	//
	// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
	MaxTokens *int `json:"max_tokens"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model CreateCompletionRequest_Model `json:"model"`

	// N How many completions to generate for each prompt.
	//
	// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
	N *int `json:"n"`

	// PresencePenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	PresencePenalty *float32 `json:"presence_penalty"`

	// Prompt The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
	//
	// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
	Prompt *CreateCompletionRequest_Prompt `json:"prompt"`

	// Seed If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
	//
	// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
	Seed *int64 `json:"seed"`

	// Stop Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
	Stop *CreateCompletionRequest_Stop `json:"stop"`

	// Stream Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
	Stream *bool `json:"stream"`

	// StreamOptions Options for streaming response. Only set this when you set `stream: true`.
	StreamOptions *ChatCompletionStreamOptions `json:"stream_options"`

	// Suffix The suffix that comes after a completion of inserted text.
	//
	// This parameter is only supported for `gpt-3.5-turbo-instruct`.
	Suffix *string `json:"suffix"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	//
	// We generally recommend altering this or `top_p` but not both.
	Temperature *float32 `json:"temperature"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or `temperature` but not both.
	TopP *float32 `json:"top_p"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateCompletionRequestModel0 defines model for .
type CreateCompletionRequestModel0 = string

// CreateCompletionRequestModel1 defines model for CreateCompletionRequest.Model.1.
type CreateCompletionRequestModel1 string

// CreateCompletionRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type CreateCompletionRequest_Model struct {
	union json.RawMessage
}

// CreateCompletionRequestPrompt0 defines model for .
type CreateCompletionRequestPrompt0 = string

// CreateCompletionRequestPrompt1 defines model for .
type CreateCompletionRequestPrompt1 = []string

// CreateCompletionRequestPrompt2 defines model for .
type CreateCompletionRequestPrompt2 = []int

// CreateCompletionRequestPrompt3 defines model for .
type CreateCompletionRequestPrompt3 = [][]int

// CreateCompletionRequest_Prompt The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
//
// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
type CreateCompletionRequest_Prompt struct {
	union json.RawMessage
}

// CreateCompletionRequestStop0 defines model for .
type CreateCompletionRequestStop0 = string

// CreateCompletionRequestStop1 defines model for .
type CreateCompletionRequestStop1 = []string

// CreateCompletionRequest_Stop Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
type CreateCompletionRequest_Stop struct {
	union json.RawMessage
}

// CreateCompletionResponse Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).
type CreateCompletionResponse struct {
	// Choices The list of completion choices the model generated for the input prompt.
	Choices []struct {
		// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
		// `length` if the maximum number of tokens specified in the request was reached,
		// or `content_filter` if content was omitted due to a flag from our content filters.
		FinishReason CreateCompletionResponseChoicesFinishReason `json:"finish_reason"`
		Index        int                                         `json:"index"`
		Logprobs     *struct {
			TextOffset    *[]int                `json:"text_offset,omitempty"`
			TokenLogprobs *[]float32            `json:"token_logprobs,omitempty"`
			Tokens        *[]string             `json:"tokens,omitempty"`
			TopLogprobs   *[]map[string]float32 `json:"top_logprobs,omitempty"`
		} `json:"logprobs"`
		Text string `json:"text"`
	} `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the completion was created.
	Created int `json:"created"`

	// Id A unique identifier for the completion.
	Id string `json:"id"`

	// Model The model used for completion.
	Model string `json:"model"`

	// Object The object type, which is always "text_completion"
	Object CreateCompletionResponseObject `json:"object"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	//
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// CreateCompletionResponseChoicesFinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// or `content_filter` if content was omitted due to a flag from our content filters.
type CreateCompletionResponseChoicesFinishReason string

// CreateCompletionResponseObject The object type, which is always "text_completion"
type CreateCompletionResponseObject string

// CreateEmbeddingRequest defines model for CreateEmbeddingRequest.
type CreateEmbeddingRequest struct {
	// Dimensions The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
	Dimensions *int `json:"dimensions,omitempty"`

	// EncodingFormat The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
	EncodingFormat *CreateEmbeddingRequestEncodingFormat `json:"encoding_format,omitempty"`

	// Input Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. Some models may also impose a limit on total number of tokens summed across inputs.
	Input CreateEmbeddingRequest_Input `json:"input"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model CreateEmbeddingRequest_Model `json:"model"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateEmbeddingRequestEncodingFormat The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
type CreateEmbeddingRequestEncodingFormat string

// CreateEmbeddingRequestInput0 The string that will be turned into an embedding.
type CreateEmbeddingRequestInput0 = string

// CreateEmbeddingRequestInput1 The array of strings that will be turned into an embedding.
type CreateEmbeddingRequestInput1 = []string

// CreateEmbeddingRequestInput2 The array of integers that will be turned into an embedding.
type CreateEmbeddingRequestInput2 = []int

// CreateEmbeddingRequestInput3 The array of arrays containing integers that will be turned into an embedding.
type CreateEmbeddingRequestInput3 = [][]int

// CreateEmbeddingRequest_Input Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. Some models may also impose a limit on total number of tokens summed across inputs.
type CreateEmbeddingRequest_Input struct {
	union json.RawMessage
}

// CreateEmbeddingRequestModel0 defines model for .
type CreateEmbeddingRequestModel0 = string

// CreateEmbeddingRequestModel1 defines model for CreateEmbeddingRequest.Model.1.
type CreateEmbeddingRequestModel1 string

// CreateEmbeddingRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type CreateEmbeddingRequest_Model struct {
	union json.RawMessage
}

// CreateEmbeddingResponse defines model for CreateEmbeddingResponse.
type CreateEmbeddingResponse struct {
	// Data The list of embeddings generated by the model.
	Data []Embedding `json:"data"`

	// Model The name of the model used to generate the embedding.
	Model string `json:"model"`

	// Object The object type, which is always "list".
	Object CreateEmbeddingResponseObject `json:"object"`

	// Usage The usage information for the request.
	Usage struct {
		// PromptTokens The number of tokens used by the prompt.
		PromptTokens int `json:"prompt_tokens"`

		// TotalTokens The total number of tokens used by the request.
		TotalTokens int `json:"total_tokens"`
	} `json:"usage"`
}

// CreateEmbeddingResponseObject The object type, which is always "list".
type CreateEmbeddingResponseObject string

// Embedding Represents an embedding vector returned by embedding endpoint.
type Embedding struct {
	// Embedding The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings).
	Embedding []float32 `json:"embedding"`

	// Index The index of the embedding in the list of embeddings.
	Index int `json:"index"`

	// Object The object type, which is always "embedding".
	Object EmbeddingObject `json:"object"`
}

// EmbeddingObject The object type, which is always "embedding".
type EmbeddingObject string

// FunctionObject defines model for FunctionObject.
type FunctionObject struct {
	// Description A description of what the function does, used by the model to choose when and how to call the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// Parameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
	//
	// Omitting `parameters` defines a function with an empty parameter list.
	Parameters *FunctionParameters `json:"parameters,omitempty"`

	// Strict Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
	Strict *bool `json:"strict"`
}

// FunctionParameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
//
// Omitting `parameters` defines a function with an empty parameter list.
type FunctionParameters map[string]interface{}

// Metadata Set of 16 key-value pairs that can be attached to an object. This can be
// useful for storing additional information about the object in a structured
// format, and querying for objects via API or the dashboard.
//
// Keys are strings with a maximum length of 64 characters. Values are strings
// with a maximum length of 512 characters.
type Metadata map[string]string

// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
type ParallelToolCalls = bool

// PredictionContent Static predicted output content, such as the content of a text file that is
// being regenerated.
type PredictionContent struct {
	// Content The content that should be matched when generating a model response.
	// If generated tokens would match this content, the entire model response
	// can be returned much more quickly.
	Content PredictionContent_Content `json:"content"`

	// Type The type of the predicted content you want to provide. This type is
	// currently always `content`.
	Type PredictionContentType `json:"type"`
}

// PredictionContentContent0 The content used for a Predicted Output. This is often the
// text of a file you are regenerating with minor changes.
type PredictionContentContent0 = string

// PredictionContentContent1 An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text inputs.
type PredictionContentContent1 = []ChatCompletionRequestMessageContentPartText

// PredictionContent_Content The content that should be matched when generating a model response.
// If generated tokens would match this content, the entire model response
// can be returned much more quickly.
type PredictionContent_Content struct {
	union json.RawMessage
}

// PredictionContentType The type of the predicted content you want to provide. This type is
// currently always `content`.
type PredictionContentType string

// ResponseFormatJsonObject defines model for ResponseFormatJsonObject.
type ResponseFormatJsonObject struct {
	// Type The type of response format being defined: `json_object`
	Type ResponseFormatJsonObjectType `json:"type"`
}

// ResponseFormatJsonObjectType The type of response format being defined: `json_object`
type ResponseFormatJsonObjectType string

// ResponseFormatJsonSchema defines model for ResponseFormatJsonSchema.
type ResponseFormatJsonSchema struct {
	JsonSchema struct {
		// Description A description of what the response format is for, used by the model to determine how to respond in the format.
		Description *string `json:"description,omitempty"`

		// Name The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
		Name string `json:"name"`

		// Schema The schema for the response format, described as a JSON Schema object.
		Schema *ResponseFormatJsonSchemaSchema `json:"schema,omitempty"`

		// Strict Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. To learn more, read the [Structured Outputs guide](/docs/guides/structured-outputs).
		Strict *bool `json:"strict"`
	} `json:"json_schema"`

	// Type The type of response format being defined: `json_schema`
	Type ResponseFormatJsonSchemaType `json:"type"`
}

// ResponseFormatJsonSchemaType The type of response format being defined: `json_schema`
type ResponseFormatJsonSchemaType string

// ResponseFormatJsonSchemaSchema The schema for the response format, described as a JSON Schema object.
type ResponseFormatJsonSchemaSchema map[string]interface{}

// ResponseFormatText defines model for ResponseFormatText.
type ResponseFormatText struct {
	// Type The type of response format being defined: `text`
	Type ResponseFormatTextType `json:"type"`
}

// ResponseFormatTextType The type of response format being defined: `text`
type ResponseFormatTextType string

// CreateChatCompletionJSONRequestBody defines body for CreateChatCompletion for application/json ContentType.
type CreateChatCompletionJSONRequestBody = CreateChatCompletionRequest

// CreateCompletionJSONRequestBody defines body for CreateCompletion for application/json ContentType.
type CreateCompletionJSONRequestBody = CreateCompletionRequest

// CreateEmbeddingJSONRequestBody defines body for CreateEmbedding for application/json ContentType.
type CreateEmbeddingJSONRequestBody = CreateEmbeddingRequest

// AsChatCompletionRequestAssistantMessageContent0 returns the union data inside the ChatCompletionRequestAssistantMessage_Content as a ChatCompletionRequestAssistantMessageContent0
func (t ChatCompletionRequestAssistantMessage_Content) AsChatCompletionRequestAssistantMessageContent0() (ChatCompletionRequestAssistantMessageContent0, error) {
	var body ChatCompletionRequestAssistantMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessageContent0 overwrites any union data inside the ChatCompletionRequestAssistantMessage_Content as the provided ChatCompletionRequestAssistantMessageContent0
func (t *ChatCompletionRequestAssistantMessage_Content) FromChatCompletionRequestAssistantMessageContent0(v ChatCompletionRequestAssistantMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessageContent0 performs a merge with any union data inside the ChatCompletionRequestAssistantMessage_Content, using the provided ChatCompletionRequestAssistantMessageContent0
func (t *ChatCompletionRequestAssistantMessage_Content) MergeChatCompletionRequestAssistantMessageContent0(v ChatCompletionRequestAssistantMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestAssistantMessageContent1 returns the union data inside the ChatCompletionRequestAssistantMessage_Content as a ChatCompletionRequestAssistantMessageContent1
func (t ChatCompletionRequestAssistantMessage_Content) AsChatCompletionRequestAssistantMessageContent1() (ChatCompletionRequestAssistantMessageContent1, error) {
	var body ChatCompletionRequestAssistantMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessageContent1 overwrites any union data inside the ChatCompletionRequestAssistantMessage_Content as the provided ChatCompletionRequestAssistantMessageContent1
func (t *ChatCompletionRequestAssistantMessage_Content) FromChatCompletionRequestAssistantMessageContent1(v ChatCompletionRequestAssistantMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessageContent1 performs a merge with any union data inside the ChatCompletionRequestAssistantMessage_Content, using the provided ChatCompletionRequestAssistantMessageContent1
func (t *ChatCompletionRequestAssistantMessage_Content) MergeChatCompletionRequestAssistantMessageContent1(v ChatCompletionRequestAssistantMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestAssistantMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestAssistantMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestAssistantMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestAssistantMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestAssistantMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestAssistantMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestAssistantMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestAssistantMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartRefusal returns the union data inside the ChatCompletionRequestAssistantMessageContentPart as a ChatCompletionRequestMessageContentPartRefusal
func (t ChatCompletionRequestAssistantMessageContentPart) AsChatCompletionRequestMessageContentPartRefusal() (ChatCompletionRequestMessageContentPartRefusal, error) {
	var body ChatCompletionRequestMessageContentPartRefusal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartRefusal overwrites any union data inside the ChatCompletionRequestAssistantMessageContentPart as the provided ChatCompletionRequestMessageContentPartRefusal
func (t *ChatCompletionRequestAssistantMessageContentPart) FromChatCompletionRequestMessageContentPartRefusal(v ChatCompletionRequestMessageContentPartRefusal) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartRefusal performs a merge with any union data inside the ChatCompletionRequestAssistantMessageContentPart, using the provided ChatCompletionRequestMessageContentPartRefusal
func (t *ChatCompletionRequestAssistantMessageContentPart) MergeChatCompletionRequestMessageContentPartRefusal(v ChatCompletionRequestMessageContentPartRefusal) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestAssistantMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestAssistantMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestDeveloperMessageContent0 returns the union data inside the ChatCompletionRequestDeveloperMessage_Content as a ChatCompletionRequestDeveloperMessageContent0
func (t ChatCompletionRequestDeveloperMessage_Content) AsChatCompletionRequestDeveloperMessageContent0() (ChatCompletionRequestDeveloperMessageContent0, error) {
	var body ChatCompletionRequestDeveloperMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestDeveloperMessageContent0 overwrites any union data inside the ChatCompletionRequestDeveloperMessage_Content as the provided ChatCompletionRequestDeveloperMessageContent0
func (t *ChatCompletionRequestDeveloperMessage_Content) FromChatCompletionRequestDeveloperMessageContent0(v ChatCompletionRequestDeveloperMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestDeveloperMessageContent0 performs a merge with any union data inside the ChatCompletionRequestDeveloperMessage_Content, using the provided ChatCompletionRequestDeveloperMessageContent0
func (t *ChatCompletionRequestDeveloperMessage_Content) MergeChatCompletionRequestDeveloperMessageContent0(v ChatCompletionRequestDeveloperMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestDeveloperMessageContent1 returns the union data inside the ChatCompletionRequestDeveloperMessage_Content as a ChatCompletionRequestDeveloperMessageContent1
func (t ChatCompletionRequestDeveloperMessage_Content) AsChatCompletionRequestDeveloperMessageContent1() (ChatCompletionRequestDeveloperMessageContent1, error) {
	var body ChatCompletionRequestDeveloperMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestDeveloperMessageContent1 overwrites any union data inside the ChatCompletionRequestDeveloperMessage_Content as the provided ChatCompletionRequestDeveloperMessageContent1
func (t *ChatCompletionRequestDeveloperMessage_Content) FromChatCompletionRequestDeveloperMessageContent1(v ChatCompletionRequestDeveloperMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestDeveloperMessageContent1 performs a merge with any union data inside the ChatCompletionRequestDeveloperMessage_Content, using the provided ChatCompletionRequestDeveloperMessageContent1
func (t *ChatCompletionRequestDeveloperMessage_Content) MergeChatCompletionRequestDeveloperMessageContent1(v ChatCompletionRequestDeveloperMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestDeveloperMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestDeveloperMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestDeveloperMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestDeveloperMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestDeveloperMessage() (ChatCompletionRequestDeveloperMessage, error) {
	var body ChatCompletionRequestDeveloperMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestDeveloperMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestDeveloperMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestDeveloperMessage(v ChatCompletionRequestDeveloperMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestDeveloperMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestDeveloperMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestDeveloperMessage(v ChatCompletionRequestDeveloperMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestSystemMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestSystemMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestSystemMessage() (ChatCompletionRequestSystemMessage, error) {
	var body ChatCompletionRequestSystemMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestSystemMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestSystemMessage(v ChatCompletionRequestSystemMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestSystemMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestSystemMessage(v ChatCompletionRequestSystemMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestUserMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestUserMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestUserMessage() (ChatCompletionRequestUserMessage, error) {
	var body ChatCompletionRequestUserMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestUserMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestUserMessage(v ChatCompletionRequestUserMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestUserMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestUserMessage(v ChatCompletionRequestUserMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestAssistantMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestAssistantMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestAssistantMessage() (ChatCompletionRequestAssistantMessage, error) {
	var body ChatCompletionRequestAssistantMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestAssistantMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestAssistantMessage(v ChatCompletionRequestAssistantMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestAssistantMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestAssistantMessage(v ChatCompletionRequestAssistantMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestToolMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestToolMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestToolMessage() (ChatCompletionRequestToolMessage, error) {
	var body ChatCompletionRequestToolMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestToolMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestToolMessage(v ChatCompletionRequestToolMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestToolMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestToolMessage(v ChatCompletionRequestToolMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestFunctionMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestFunctionMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestFunctionMessage() (ChatCompletionRequestFunctionMessage, error) {
	var body ChatCompletionRequestFunctionMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestFunctionMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestFunctionMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestFunctionMessage(v ChatCompletionRequestFunctionMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestFunctionMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestFunctionMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestFunctionMessage(v ChatCompletionRequestFunctionMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestMessage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestMessage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestSystemMessageContent0 returns the union data inside the ChatCompletionRequestSystemMessage_Content as a ChatCompletionRequestSystemMessageContent0
func (t ChatCompletionRequestSystemMessage_Content) AsChatCompletionRequestSystemMessageContent0() (ChatCompletionRequestSystemMessageContent0, error) {
	var body ChatCompletionRequestSystemMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessageContent0 overwrites any union data inside the ChatCompletionRequestSystemMessage_Content as the provided ChatCompletionRequestSystemMessageContent0
func (t *ChatCompletionRequestSystemMessage_Content) FromChatCompletionRequestSystemMessageContent0(v ChatCompletionRequestSystemMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessageContent0 performs a merge with any union data inside the ChatCompletionRequestSystemMessage_Content, using the provided ChatCompletionRequestSystemMessageContent0
func (t *ChatCompletionRequestSystemMessage_Content) MergeChatCompletionRequestSystemMessageContent0(v ChatCompletionRequestSystemMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestSystemMessageContent1 returns the union data inside the ChatCompletionRequestSystemMessage_Content as a ChatCompletionRequestSystemMessageContent1
func (t ChatCompletionRequestSystemMessage_Content) AsChatCompletionRequestSystemMessageContent1() (ChatCompletionRequestSystemMessageContent1, error) {
	var body ChatCompletionRequestSystemMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessageContent1 overwrites any union data inside the ChatCompletionRequestSystemMessage_Content as the provided ChatCompletionRequestSystemMessageContent1
func (t *ChatCompletionRequestSystemMessage_Content) FromChatCompletionRequestSystemMessageContent1(v ChatCompletionRequestSystemMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessageContent1 performs a merge with any union data inside the ChatCompletionRequestSystemMessage_Content, using the provided ChatCompletionRequestSystemMessageContent1
func (t *ChatCompletionRequestSystemMessage_Content) MergeChatCompletionRequestSystemMessageContent1(v ChatCompletionRequestSystemMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestSystemMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestSystemMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestSystemMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestSystemMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestSystemMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestSystemMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestSystemMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestSystemMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestSystemMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestSystemMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestToolMessageContent0 returns the union data inside the ChatCompletionRequestToolMessage_Content as a ChatCompletionRequestToolMessageContent0
func (t ChatCompletionRequestToolMessage_Content) AsChatCompletionRequestToolMessageContent0() (ChatCompletionRequestToolMessageContent0, error) {
	var body ChatCompletionRequestToolMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessageContent0 overwrites any union data inside the ChatCompletionRequestToolMessage_Content as the provided ChatCompletionRequestToolMessageContent0
func (t *ChatCompletionRequestToolMessage_Content) FromChatCompletionRequestToolMessageContent0(v ChatCompletionRequestToolMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessageContent0 performs a merge with any union data inside the ChatCompletionRequestToolMessage_Content, using the provided ChatCompletionRequestToolMessageContent0
func (t *ChatCompletionRequestToolMessage_Content) MergeChatCompletionRequestToolMessageContent0(v ChatCompletionRequestToolMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestToolMessageContent1 returns the union data inside the ChatCompletionRequestToolMessage_Content as a ChatCompletionRequestToolMessageContent1
func (t ChatCompletionRequestToolMessage_Content) AsChatCompletionRequestToolMessageContent1() (ChatCompletionRequestToolMessageContent1, error) {
	var body ChatCompletionRequestToolMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessageContent1 overwrites any union data inside the ChatCompletionRequestToolMessage_Content as the provided ChatCompletionRequestToolMessageContent1
func (t *ChatCompletionRequestToolMessage_Content) FromChatCompletionRequestToolMessageContent1(v ChatCompletionRequestToolMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessageContent1 performs a merge with any union data inside the ChatCompletionRequestToolMessage_Content, using the provided ChatCompletionRequestToolMessageContent1
func (t *ChatCompletionRequestToolMessage_Content) MergeChatCompletionRequestToolMessageContent1(v ChatCompletionRequestToolMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestToolMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestToolMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestToolMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestToolMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestToolMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestToolMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestToolMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestToolMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestToolMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestToolMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestUserMessageContent0 returns the union data inside the ChatCompletionRequestUserMessage_Content as a ChatCompletionRequestUserMessageContent0
func (t ChatCompletionRequestUserMessage_Content) AsChatCompletionRequestUserMessageContent0() (ChatCompletionRequestUserMessageContent0, error) {
	var body ChatCompletionRequestUserMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessageContent0 overwrites any union data inside the ChatCompletionRequestUserMessage_Content as the provided ChatCompletionRequestUserMessageContent0
func (t *ChatCompletionRequestUserMessage_Content) FromChatCompletionRequestUserMessageContent0(v ChatCompletionRequestUserMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessageContent0 performs a merge with any union data inside the ChatCompletionRequestUserMessage_Content, using the provided ChatCompletionRequestUserMessageContent0
func (t *ChatCompletionRequestUserMessage_Content) MergeChatCompletionRequestUserMessageContent0(v ChatCompletionRequestUserMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestUserMessageContent1 returns the union data inside the ChatCompletionRequestUserMessage_Content as a ChatCompletionRequestUserMessageContent1
func (t ChatCompletionRequestUserMessage_Content) AsChatCompletionRequestUserMessageContent1() (ChatCompletionRequestUserMessageContent1, error) {
	var body ChatCompletionRequestUserMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessageContent1 overwrites any union data inside the ChatCompletionRequestUserMessage_Content as the provided ChatCompletionRequestUserMessageContent1
func (t *ChatCompletionRequestUserMessage_Content) FromChatCompletionRequestUserMessageContent1(v ChatCompletionRequestUserMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessageContent1 performs a merge with any union data inside the ChatCompletionRequestUserMessage_Content, using the provided ChatCompletionRequestUserMessageContent1
func (t *ChatCompletionRequestUserMessage_Content) MergeChatCompletionRequestUserMessageContent1(v ChatCompletionRequestUserMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestUserMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestUserMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartImage returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartImage
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartImage() (ChatCompletionRequestMessageContentPartImage, error) {
	var body ChatCompletionRequestMessageContentPartImage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartImage overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartImage
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartImage(v ChatCompletionRequestMessageContentPartImage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartImage performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartImage
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartImage(v ChatCompletionRequestMessageContentPartImage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartAudio returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartAudio
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartAudio() (ChatCompletionRequestMessageContentPartAudio, error) {
	var body ChatCompletionRequestMessageContentPartAudio
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartAudio overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartAudio
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartAudio(v ChatCompletionRequestMessageContentPartAudio) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartAudio performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartAudio
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartAudio(v ChatCompletionRequestMessageContentPartAudio) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestUserMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestUserMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionToolChoiceOption0 returns the union data inside the ChatCompletionToolChoiceOption as a ChatCompletionToolChoiceOption0
func (t ChatCompletionToolChoiceOption) AsChatCompletionToolChoiceOption0() (ChatCompletionToolChoiceOption0, error) {
	var body ChatCompletionToolChoiceOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionToolChoiceOption0 overwrites any union data inside the ChatCompletionToolChoiceOption as the provided ChatCompletionToolChoiceOption0
func (t *ChatCompletionToolChoiceOption) FromChatCompletionToolChoiceOption0(v ChatCompletionToolChoiceOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionToolChoiceOption0 performs a merge with any union data inside the ChatCompletionToolChoiceOption, using the provided ChatCompletionToolChoiceOption0
func (t *ChatCompletionToolChoiceOption) MergeChatCompletionToolChoiceOption0(v ChatCompletionToolChoiceOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionNamedToolChoice returns the union data inside the ChatCompletionToolChoiceOption as a ChatCompletionNamedToolChoice
func (t ChatCompletionToolChoiceOption) AsChatCompletionNamedToolChoice() (ChatCompletionNamedToolChoice, error) {
	var body ChatCompletionNamedToolChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionNamedToolChoice overwrites any union data inside the ChatCompletionToolChoiceOption as the provided ChatCompletionNamedToolChoice
func (t *ChatCompletionToolChoiceOption) FromChatCompletionNamedToolChoice(v ChatCompletionNamedToolChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionNamedToolChoice performs a merge with any union data inside the ChatCompletionToolChoiceOption, using the provided ChatCompletionNamedToolChoice
func (t *ChatCompletionToolChoiceOption) MergeChatCompletionNamedToolChoice(v ChatCompletionNamedToolChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionToolChoiceOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionToolChoiceOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestFunctionCall0 returns the union data inside the CreateChatCompletionRequest_FunctionCall as a CreateChatCompletionRequestFunctionCall0
func (t CreateChatCompletionRequest_FunctionCall) AsCreateChatCompletionRequestFunctionCall0() (CreateChatCompletionRequestFunctionCall0, error) {
	var body CreateChatCompletionRequestFunctionCall0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestFunctionCall0 overwrites any union data inside the CreateChatCompletionRequest_FunctionCall as the provided CreateChatCompletionRequestFunctionCall0
func (t *CreateChatCompletionRequest_FunctionCall) FromCreateChatCompletionRequestFunctionCall0(v CreateChatCompletionRequestFunctionCall0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestFunctionCall0 performs a merge with any union data inside the CreateChatCompletionRequest_FunctionCall, using the provided CreateChatCompletionRequestFunctionCall0
func (t *CreateChatCompletionRequest_FunctionCall) MergeCreateChatCompletionRequestFunctionCall0(v CreateChatCompletionRequestFunctionCall0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionFunctionCallOption returns the union data inside the CreateChatCompletionRequest_FunctionCall as a ChatCompletionFunctionCallOption
func (t CreateChatCompletionRequest_FunctionCall) AsChatCompletionFunctionCallOption() (ChatCompletionFunctionCallOption, error) {
	var body ChatCompletionFunctionCallOption
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionFunctionCallOption overwrites any union data inside the CreateChatCompletionRequest_FunctionCall as the provided ChatCompletionFunctionCallOption
func (t *CreateChatCompletionRequest_FunctionCall) FromChatCompletionFunctionCallOption(v ChatCompletionFunctionCallOption) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionFunctionCallOption performs a merge with any union data inside the CreateChatCompletionRequest_FunctionCall, using the provided ChatCompletionFunctionCallOption
func (t *CreateChatCompletionRequest_FunctionCall) MergeChatCompletionFunctionCallOption(v ChatCompletionFunctionCallOption) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_FunctionCall) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_FunctionCall) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestModel0 returns the union data inside the CreateChatCompletionRequest_Model as a CreateChatCompletionRequestModel0
func (t CreateChatCompletionRequest_Model) AsCreateChatCompletionRequestModel0() (CreateChatCompletionRequestModel0, error) {
	var body CreateChatCompletionRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestModel0 overwrites any union data inside the CreateChatCompletionRequest_Model as the provided CreateChatCompletionRequestModel0
func (t *CreateChatCompletionRequest_Model) FromCreateChatCompletionRequestModel0(v CreateChatCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestModel0 performs a merge with any union data inside the CreateChatCompletionRequest_Model, using the provided CreateChatCompletionRequestModel0
func (t *CreateChatCompletionRequest_Model) MergeCreateChatCompletionRequestModel0(v CreateChatCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateChatCompletionRequestModel1 returns the union data inside the CreateChatCompletionRequest_Model as a CreateChatCompletionRequestModel1
func (t CreateChatCompletionRequest_Model) AsCreateChatCompletionRequestModel1() (CreateChatCompletionRequestModel1, error) {
	var body CreateChatCompletionRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestModel1 overwrites any union data inside the CreateChatCompletionRequest_Model as the provided CreateChatCompletionRequestModel1
func (t *CreateChatCompletionRequest_Model) FromCreateChatCompletionRequestModel1(v CreateChatCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestModel1 performs a merge with any union data inside the CreateChatCompletionRequest_Model, using the provided CreateChatCompletionRequestModel1
func (t *CreateChatCompletionRequest_Model) MergeCreateChatCompletionRequestModel1(v CreateChatCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPredictionContent returns the union data inside the CreateChatCompletionRequest_Prediction as a PredictionContent
func (t CreateChatCompletionRequest_Prediction) AsPredictionContent() (PredictionContent, error) {
	var body PredictionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContent overwrites any union data inside the CreateChatCompletionRequest_Prediction as the provided PredictionContent
func (t *CreateChatCompletionRequest_Prediction) FromPredictionContent(v PredictionContent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContent performs a merge with any union data inside the CreateChatCompletionRequest_Prediction, using the provided PredictionContent
func (t *CreateChatCompletionRequest_Prediction) MergePredictionContent(v PredictionContent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Prediction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Prediction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResponseFormatText returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatText
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatText() (ResponseFormatText, error) {
	var body ResponseFormatText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatText overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatText
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatText performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatText
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonObject returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatJsonObject
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatJsonObject() (ResponseFormatJsonObject, error) {
	var body ResponseFormatJsonObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonObject overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatJsonObject
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonObject performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatJsonObject
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonSchema returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatJsonSchema
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatJsonSchema() (ResponseFormatJsonSchema, error) {
	var body ResponseFormatJsonSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonSchema overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatJsonSchema
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonSchema performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatJsonSchema
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_ResponseFormat) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_ResponseFormat) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestStop0 returns the union data inside the CreateChatCompletionRequest_Stop as a CreateChatCompletionRequestStop0
func (t CreateChatCompletionRequest_Stop) AsCreateChatCompletionRequestStop0() (CreateChatCompletionRequestStop0, error) {
	var body CreateChatCompletionRequestStop0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestStop0 overwrites any union data inside the CreateChatCompletionRequest_Stop as the provided CreateChatCompletionRequestStop0
func (t *CreateChatCompletionRequest_Stop) FromCreateChatCompletionRequestStop0(v CreateChatCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestStop0 performs a merge with any union data inside the CreateChatCompletionRequest_Stop, using the provided CreateChatCompletionRequestStop0
func (t *CreateChatCompletionRequest_Stop) MergeCreateChatCompletionRequestStop0(v CreateChatCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateChatCompletionRequestStop1 returns the union data inside the CreateChatCompletionRequest_Stop as a CreateChatCompletionRequestStop1
func (t CreateChatCompletionRequest_Stop) AsCreateChatCompletionRequestStop1() (CreateChatCompletionRequestStop1, error) {
	var body CreateChatCompletionRequestStop1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestStop1 overwrites any union data inside the CreateChatCompletionRequest_Stop as the provided CreateChatCompletionRequestStop1
func (t *CreateChatCompletionRequest_Stop) FromCreateChatCompletionRequestStop1(v CreateChatCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestStop1 performs a merge with any union data inside the CreateChatCompletionRequest_Stop, using the provided CreateChatCompletionRequestStop1
func (t *CreateChatCompletionRequest_Stop) MergeCreateChatCompletionRequestStop1(v CreateChatCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestModel0 returns the union data inside the CreateCompletionRequest_Model as a CreateCompletionRequestModel0
func (t CreateCompletionRequest_Model) AsCreateCompletionRequestModel0() (CreateCompletionRequestModel0, error) {
	var body CreateCompletionRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestModel0 overwrites any union data inside the CreateCompletionRequest_Model as the provided CreateCompletionRequestModel0
func (t *CreateCompletionRequest_Model) FromCreateCompletionRequestModel0(v CreateCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestModel0 performs a merge with any union data inside the CreateCompletionRequest_Model, using the provided CreateCompletionRequestModel0
func (t *CreateCompletionRequest_Model) MergeCreateCompletionRequestModel0(v CreateCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestModel1 returns the union data inside the CreateCompletionRequest_Model as a CreateCompletionRequestModel1
func (t CreateCompletionRequest_Model) AsCreateCompletionRequestModel1() (CreateCompletionRequestModel1, error) {
	var body CreateCompletionRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestModel1 overwrites any union data inside the CreateCompletionRequest_Model as the provided CreateCompletionRequestModel1
func (t *CreateCompletionRequest_Model) FromCreateCompletionRequestModel1(v CreateCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestModel1 performs a merge with any union data inside the CreateCompletionRequest_Model, using the provided CreateCompletionRequestModel1
func (t *CreateCompletionRequest_Model) MergeCreateCompletionRequestModel1(v CreateCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestPrompt0 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt0
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt0() (CreateCompletionRequestPrompt0, error) {
	var body CreateCompletionRequestPrompt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt0 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt0
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt0(v CreateCompletionRequestPrompt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt0 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt0
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt0(v CreateCompletionRequestPrompt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt1 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt1
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt1() (CreateCompletionRequestPrompt1, error) {
	var body CreateCompletionRequestPrompt1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt1 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt1
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt1(v CreateCompletionRequestPrompt1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt1 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt1
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt1(v CreateCompletionRequestPrompt1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt2 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt2
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt2() (CreateCompletionRequestPrompt2, error) {
	var body CreateCompletionRequestPrompt2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt2 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt2
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt2(v CreateCompletionRequestPrompt2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt2 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt2
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt2(v CreateCompletionRequestPrompt2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt3 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt3
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt3() (CreateCompletionRequestPrompt3, error) {
	var body CreateCompletionRequestPrompt3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt3 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt3
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt3(v CreateCompletionRequestPrompt3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt3 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt3
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt3(v CreateCompletionRequestPrompt3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Prompt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Prompt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestStop0 returns the union data inside the CreateCompletionRequest_Stop as a CreateCompletionRequestStop0
func (t CreateCompletionRequest_Stop) AsCreateCompletionRequestStop0() (CreateCompletionRequestStop0, error) {
	var body CreateCompletionRequestStop0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestStop0 overwrites any union data inside the CreateCompletionRequest_Stop as the provided CreateCompletionRequestStop0
func (t *CreateCompletionRequest_Stop) FromCreateCompletionRequestStop0(v CreateCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestStop0 performs a merge with any union data inside the CreateCompletionRequest_Stop, using the provided CreateCompletionRequestStop0
func (t *CreateCompletionRequest_Stop) MergeCreateCompletionRequestStop0(v CreateCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestStop1 returns the union data inside the CreateCompletionRequest_Stop as a CreateCompletionRequestStop1
func (t CreateCompletionRequest_Stop) AsCreateCompletionRequestStop1() (CreateCompletionRequestStop1, error) {
	var body CreateCompletionRequestStop1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestStop1 overwrites any union data inside the CreateCompletionRequest_Stop as the provided CreateCompletionRequestStop1
func (t *CreateCompletionRequest_Stop) FromCreateCompletionRequestStop1(v CreateCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestStop1 performs a merge with any union data inside the CreateCompletionRequest_Stop, using the provided CreateCompletionRequestStop1
func (t *CreateCompletionRequest_Stop) MergeCreateCompletionRequestStop1(v CreateCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateEmbeddingRequestInput0 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput0
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput0() (CreateEmbeddingRequestInput0, error) {
	var body CreateEmbeddingRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput0 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput0
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput0(v CreateEmbeddingRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput0 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput0
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput0(v CreateEmbeddingRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput1 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput1
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput1() (CreateEmbeddingRequestInput1, error) {
	var body CreateEmbeddingRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput1 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput1
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput1(v CreateEmbeddingRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput1 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput1
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput1(v CreateEmbeddingRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput2 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput2
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput2() (CreateEmbeddingRequestInput2, error) {
	var body CreateEmbeddingRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput2 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput2
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput2(v CreateEmbeddingRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput2 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput2
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput2(v CreateEmbeddingRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput3 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput3
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput3() (CreateEmbeddingRequestInput3, error) {
	var body CreateEmbeddingRequestInput3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput3 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput3
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput3(v CreateEmbeddingRequestInput3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput3 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput3
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput3(v CreateEmbeddingRequestInput3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateEmbeddingRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateEmbeddingRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateEmbeddingRequestModel0 returns the union data inside the CreateEmbeddingRequest_Model as a CreateEmbeddingRequestModel0
func (t CreateEmbeddingRequest_Model) AsCreateEmbeddingRequestModel0() (CreateEmbeddingRequestModel0, error) {
	var body CreateEmbeddingRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestModel0 overwrites any union data inside the CreateEmbeddingRequest_Model as the provided CreateEmbeddingRequestModel0
func (t *CreateEmbeddingRequest_Model) FromCreateEmbeddingRequestModel0(v CreateEmbeddingRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestModel0 performs a merge with any union data inside the CreateEmbeddingRequest_Model, using the provided CreateEmbeddingRequestModel0
func (t *CreateEmbeddingRequest_Model) MergeCreateEmbeddingRequestModel0(v CreateEmbeddingRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestModel1 returns the union data inside the CreateEmbeddingRequest_Model as a CreateEmbeddingRequestModel1
func (t CreateEmbeddingRequest_Model) AsCreateEmbeddingRequestModel1() (CreateEmbeddingRequestModel1, error) {
	var body CreateEmbeddingRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestModel1 overwrites any union data inside the CreateEmbeddingRequest_Model as the provided CreateEmbeddingRequestModel1
func (t *CreateEmbeddingRequest_Model) FromCreateEmbeddingRequestModel1(v CreateEmbeddingRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestModel1 performs a merge with any union data inside the CreateEmbeddingRequest_Model, using the provided CreateEmbeddingRequestModel1
func (t *CreateEmbeddingRequest_Model) MergeCreateEmbeddingRequestModel1(v CreateEmbeddingRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateEmbeddingRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateEmbeddingRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPredictionContentContent0 returns the union data inside the PredictionContent_Content as a PredictionContentContent0
func (t PredictionContent_Content) AsPredictionContentContent0() (PredictionContentContent0, error) {
	var body PredictionContentContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContentContent0 overwrites any union data inside the PredictionContent_Content as the provided PredictionContentContent0
func (t *PredictionContent_Content) FromPredictionContentContent0(v PredictionContentContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContentContent0 performs a merge with any union data inside the PredictionContent_Content, using the provided PredictionContentContent0
func (t *PredictionContent_Content) MergePredictionContentContent0(v PredictionContentContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPredictionContentContent1 returns the union data inside the PredictionContent_Content as a PredictionContentContent1
func (t PredictionContent_Content) AsPredictionContentContent1() (PredictionContentContent1, error) {
	var body PredictionContentContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContentContent1 overwrites any union data inside the PredictionContent_Content as the provided PredictionContentContent1
func (t *PredictionContent_Content) FromPredictionContentContent1(v PredictionContentContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContentContent1 performs a merge with any union data inside the PredictionContent_Content, using the provided PredictionContentContent1
func (t *PredictionContent_Content) MergePredictionContentContent1(v PredictionContentContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PredictionContent_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PredictionContent_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateChatCompletionWithBody request with any body
	CreateChatCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChatCompletion(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCompletionWithBody request with any body
	CreateCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCompletion(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmbeddingWithBody request with any body
	CreateEmbeddingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmbedding(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateChatCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatCompletionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChatCompletion(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatCompletionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompletionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompletion(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompletionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmbeddingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmbeddingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmbedding(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmbeddingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateChatCompletionRequest calls the generic CreateChatCompletion builder with application/json body
func NewCreateChatCompletionRequest(server string, body CreateChatCompletionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChatCompletionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateChatCompletionRequestWithBody generates requests for CreateChatCompletion with any type of body
func NewCreateChatCompletionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCompletionRequest calls the generic CreateCompletion builder with application/json body
func NewCreateCompletionRequest(server string, body CreateCompletionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCompletionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCompletionRequestWithBody generates requests for CreateCompletion with any type of body
func NewCreateCompletionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEmbeddingRequest calls the generic CreateEmbedding builder with application/json body
func NewCreateEmbeddingRequest(server string, body CreateEmbeddingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmbeddingRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEmbeddingRequestWithBody generates requests for CreateEmbedding with any type of body
func NewCreateEmbeddingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeddings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateChatCompletionWithBodyWithResponse request with any body
	CreateChatCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatCompletionResponseModel, error)

	CreateChatCompletionWithResponse(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatCompletionResponseModel, error)

	// CreateCompletionWithBodyWithResponse request with any body
	CreateCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompletionResponseModel, error)

	CreateCompletionWithResponse(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompletionResponseModel, error)

	// CreateEmbeddingWithBodyWithResponse request with any body
	CreateEmbeddingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmbeddingResponseModel, error)

	CreateEmbeddingWithResponse(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmbeddingResponseModel, error)
}

type CreateChatCompletionResponseModel struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateChatCompletionResponse
}

// Status returns HTTPResponse.Status
func (r CreateChatCompletionResponseModel) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChatCompletionResponseModel) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCompletionResponseModel struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCompletionResponse
}

// Status returns HTTPResponse.Status
func (r CreateCompletionResponseModel) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompletionResponseModel) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmbeddingResponseModel struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateEmbeddingResponse
}

// Status returns HTTPResponse.Status
func (r CreateEmbeddingResponseModel) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmbeddingResponseModel) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateChatCompletionWithBodyWithResponse request with arbitrary body returning *CreateChatCompletionResponseModel
func (c *ClientWithResponses) CreateChatCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatCompletionResponseModel, error) {
	rsp, err := c.CreateChatCompletionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatCompletionResponseModel(rsp)
}

func (c *ClientWithResponses) CreateChatCompletionWithResponse(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatCompletionResponseModel, error) {
	rsp, err := c.CreateChatCompletion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatCompletionResponseModel(rsp)
}

// CreateCompletionWithBodyWithResponse request with arbitrary body returning *CreateCompletionResponseModel
func (c *ClientWithResponses) CreateCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompletionResponseModel, error) {
	rsp, err := c.CreateCompletionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompletionResponseModel(rsp)
}

func (c *ClientWithResponses) CreateCompletionWithResponse(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompletionResponseModel, error) {
	rsp, err := c.CreateCompletion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompletionResponseModel(rsp)
}

// CreateEmbeddingWithBodyWithResponse request with arbitrary body returning *CreateEmbeddingResponseModel
func (c *ClientWithResponses) CreateEmbeddingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmbeddingResponseModel, error) {
	rsp, err := c.CreateEmbeddingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmbeddingResponseModel(rsp)
}

func (c *ClientWithResponses) CreateEmbeddingWithResponse(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmbeddingResponseModel, error) {
	rsp, err := c.CreateEmbedding(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmbeddingResponseModel(rsp)
}

// ParseCreateChatCompletionResponseModel parses an HTTP response from a CreateChatCompletionWithResponse call
func ParseCreateChatCompletionResponseModel(rsp *http.Response) (*CreateChatCompletionResponseModel, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateChatCompletionResponseModel{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateChatCompletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/event-stream) unsupported

	}

	return response, nil
}

// ParseCreateCompletionResponseModel parses an HTTP response from a CreateCompletionWithResponse call
func ParseCreateCompletionResponseModel(rsp *http.Response) (*CreateCompletionResponseModel, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCompletionResponseModel{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCompletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEmbeddingResponseModel parses an HTTP response from a CreateEmbeddingWithResponse call
func ParseCreateEmbeddingResponseModel(rsp *http.Response) (*CreateEmbeddingResponseModel, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmbeddingResponseModel{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateEmbeddingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Creates a model response for the given chat conversation. Learn more in the
	// [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision),
	// and [audio](/docs/guides/audio) guides.
	//
	// Parameter support can differ depending on the model used to generate the
	// response, particularly for newer reasoning models. Parameters that are only
	// supported for reasoning models are noted below. For the current state of
	// unsupported parameters in reasoning models,
	// [refer to the reasoning guide](/docs/guides/reasoning).
	// (POST /chat/completions)
	CreateChatCompletion(w http.ResponseWriter, r *http.Request)
	// Creates a completion for the provided prompt and parameters.
	// (POST /completions)
	CreateCompletion(w http.ResponseWriter, r *http.Request)
	// Creates an embedding vector representing the input text.
	// (POST /embeddings)
	CreateEmbedding(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateChatCompletion operation middleware
func (siw *ServerInterfaceWrapper) CreateChatCompletion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateChatCompletion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateCompletion operation middleware
func (siw *ServerInterfaceWrapper) CreateCompletion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCompletion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateEmbedding operation middleware
func (siw *ServerInterfaceWrapper) CreateEmbedding(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateEmbedding(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chat/completions", wrapper.CreateChatCompletion)
	m.HandleFunc("POST "+options.BaseURL+"/completions", wrapper.CreateCompletion)
	m.HandleFunc("POST "+options.BaseURL+"/embeddings", wrapper.CreateEmbedding)

	return m
}
