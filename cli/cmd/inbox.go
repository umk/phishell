package cmd

import (
	"context"
	_ "embed"
	"fmt"
	"os"
	"sync"

	"github.com/umk/phishell/bootstrap"
	"github.com/umk/phishell/cli/session"
	"github.com/umk/phishell/util/execx"
	"github.com/umk/phishell/util/termx"
)

const inboxHeader = "The inbox displays a list of messages generated by background processes. " +
	"To take further action on a message, select it from the list. " +
	"Once selected, the message will be removed from the inbox."

const inboxFooter = "Press ENTER to select, BACKSPACE to delete, ESC to close"

type InboxCommand struct {
	context *Context
}

func (c *InboxCommand) Execute(ctx context.Context, args execx.Arguments) error {
	screen, err := termx.NewScreen()
	if err != nil {
		return err
	}

	var fini sync.Once

	defer fini.Do(screen.Fini)

	render, err := newInboxRender(screen, c.context)
	if err != nil {
		return err
	}

	app := bootstrap.GetApp(ctx)

	client := app.PrimaryClient()

	return render.drawInbox(func(message *session.InboxMessage) error {
		fini.Do(screen.Fini)

		fmt.Println(message.Content)

		k, err := termx.ReadKeyOrDefaultOf("Continue? (Y/n) ", 'y', 'n')
		if err != nil {
			return err
		}

		if k == 'n' {
			return nil
		}

		// Change current directory to the home directory
		previousWd, err := os.Getwd()
		if err != nil {
			return err
		}

		currentWd := message.Wd

		if currentWd == "" {
			homeDir, err := os.UserHomeDir()
			if err != nil {
				return err
			}

			currentWd = homeDir
		}

		if err := os.Chdir(currentWd); err != nil {
			return err
		}

		defer os.Chdir(previousWd)

		return c.context.session.ProcessChat(ctx, client, message.Content)
	})
}

func (c *InboxCommand) Info() string {
	return "inbox: show the list of incoming messages from background process"
}
